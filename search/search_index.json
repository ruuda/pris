{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pris Pris is a domain-specific language for designing slides and other graphics. Pris allows you to write drawing commands in a lightweight programming language tailored for the task, and compile that to PDF . Graphics can be parametrized easily, and instead of copy-pasting, common elements can be extracted into reusable functions. Features Compiles to PDF . Full typographic control. First class graphics that can be inspected and manipulated as values. First class functions. Example The obligatory \u201chello world\u201d: { put t(\"Hello world\") at (0.1w, 0.5h) } This produces a single page, with the text \u201cHello world\u201d in the default sans-serif font. The leftmost point on the text baseline is located at 10% of the canvas width and 50% of the canvas height. Getting started Pris needs to be built from source. See the building chapter of the docs. Then you might want to take a look at the examples . Please note that Pris is alpha-quality software. Expect things to break.","title":"Overview"},{"location":"#pris","text":"Pris is a domain-specific language for designing slides and other graphics. Pris allows you to write drawing commands in a lightweight programming language tailored for the task, and compile that to PDF . Graphics can be parametrized easily, and instead of copy-pasting, common elements can be extracted into reusable functions.","title":"Pris"},{"location":"#features","text":"Compiles to PDF . Full typographic control. First class graphics that can be inspected and manipulated as values. First class functions.","title":"Features"},{"location":"#example","text":"The obligatory \u201chello world\u201d: { put t(\"Hello world\") at (0.1w, 0.5h) } This produces a single page, with the text \u201cHello world\u201d in the default sans-serif font. The leftmost point on the text baseline is located at 10% of the canvas width and 50% of the canvas height.","title":"Example"},{"location":"#getting-started","text":"Pris needs to be built from source. See the building chapter of the docs. Then you might want to take a look at the examples . Please note that Pris is alpha-quality software. Expect things to break.","title":"Getting started"},{"location":"background/","text":"Background Below are some observations that inspired the design of Pris. Observations While a declarative source with a theme (such as html with css, or LaTeX) works great for long documents, it is somewhat inflexible for slides. Good slides need to be designed, and this is much more a manual process than typesetting large blocks of text. If you want to be able to change themes with a single click, then you need to shoehorn slides into a pretty limited format. Separating markup from content is not a good idea for creative slides: markup is an important part of the content. Conclusion : Don\u2019t try to separate semantics from markup. Specifying semantics is a non-goal. Offer full control over markup instead. To design graphics (which is what good slides should be), a graphical editor can be much nicer than a declarative format. Compare Inkscape with LaTeX and TikZ. However, a text-based declarative format has several advantages: it is nicer to work with in source control, and it can easily be scripted. Compare animating a hand-drawn graph in Google Slides with animating a TikZ drawing in LaTeX and Beamer. Manual animation often involves copying the entire thing, after which changing parts becomes difficult. It is possible to build a graphical editor for a text-based format, but these often produce messy output. Conclusion : A declarative text-based input format that is intended to be written by humans is preferred over an opaque format with a graphical editor. Supporting external graphics (svg logos, jpeg photographs, png graphics) is a must. For consistent graphics, having basic drawing capabilities embedded would be useful (like TikZ in LaTex). The possibility to leverage external tools is limited if consistency is a goal. (For instance, even if the same font is used in externally drawn graphics, the graphic must be scaled to make font sizes match.) Care must be taken to keep the scope narrow: TikZ is a huge project in itself. Conclusion : Allow placing external graphics and expose a minimal but sufficient set of embedded drawing operations.","title":"Background"},{"location":"background/#background","text":"Below are some observations that inspired the design of Pris.","title":"Background"},{"location":"background/#observations","text":"While a declarative source with a theme (such as html with css, or LaTeX) works great for long documents, it is somewhat inflexible for slides. Good slides need to be designed, and this is much more a manual process than typesetting large blocks of text. If you want to be able to change themes with a single click, then you need to shoehorn slides into a pretty limited format. Separating markup from content is not a good idea for creative slides: markup is an important part of the content. Conclusion : Don\u2019t try to separate semantics from markup. Specifying semantics is a non-goal. Offer full control over markup instead. To design graphics (which is what good slides should be), a graphical editor can be much nicer than a declarative format. Compare Inkscape with LaTeX and TikZ. However, a text-based declarative format has several advantages: it is nicer to work with in source control, and it can easily be scripted. Compare animating a hand-drawn graph in Google Slides with animating a TikZ drawing in LaTeX and Beamer. Manual animation often involves copying the entire thing, after which changing parts becomes difficult. It is possible to build a graphical editor for a text-based format, but these often produce messy output. Conclusion : A declarative text-based input format that is intended to be written by humans is preferred over an opaque format with a graphical editor. Supporting external graphics (svg logos, jpeg photographs, png graphics) is a must. For consistent graphics, having basic drawing capabilities embedded would be useful (like TikZ in LaTex). The possibility to leverage external tools is limited if consistency is a goal. (For instance, even if the same font is used in externally drawn graphics, the graphic must be scaled to make font sizes match.) Care must be taken to keep the scope narrow: TikZ is a huge project in itself. Conclusion : Allow placing external graphics and expose a minimal but sufficient set of embedded drawing operations.","title":"Observations"},{"location":"building/","text":"Building Pris is written in Rust and builds with Cargo, the build tool bundled with Rust. When system dependencies are installed, cargo build is sufficient. git clone https://github.com/ruuda/pris cd pris cargo build --release target/release/pris --help target/release/pris examples/lines.pris evince examples/lines.pdf If building does not succeed at first, some system dependencies might not be installed. See below. Linux To install system dependencies on Ubuntu: apt install libcairo2-dev libharfbuzz-dev librsvg2-dev To install system dependencies on Arch Linux: pacman -S --needed cairo harfbuzz librsvg fontconfig freetype2 Mac On Mac, system dependencies can be installed through Homebrew: brew install cairo harfbuzz librsvg fontconfig Windows On Windows, system dependencies can be installed inside an MSYS2 environment. More information will follow soon. For now, check out the windows branch for more information.","title":"Building"},{"location":"building/#building","text":"Pris is written in Rust and builds with Cargo, the build tool bundled with Rust. When system dependencies are installed, cargo build is sufficient. git clone https://github.com/ruuda/pris cd pris cargo build --release target/release/pris --help target/release/pris examples/lines.pris evince examples/lines.pdf If building does not succeed at first, some system dependencies might not be installed. See below.","title":"Building"},{"location":"building/#linux","text":"To install system dependencies on Ubuntu: apt install libcairo2-dev libharfbuzz-dev librsvg2-dev To install system dependencies on Arch Linux: pacman -S --needed cairo harfbuzz librsvg fontconfig freetype2","title":"Linux"},{"location":"building/#mac","text":"On Mac, system dependencies can be installed through Homebrew: brew install cairo harfbuzz librsvg fontconfig","title":"Mac"},{"location":"building/#windows","text":"On Windows, system dependencies can be installed inside an MSYS2 environment. More information will follow soon. For now, check out the windows branch for more information.","title":"Windows"},{"location":"getting-started/","text":"Getting started As there are currently no binaries for Pris, the first step is to build Pris from source, as explained in the building chapter. For now, the best way to get started is to take a look at the examples . This document will be extended in the future.","title":"Getting started"},{"location":"getting-started/#getting-started","text":"As there are currently no binaries for Pris, the first step is to build Pris from source, as explained in the building chapter. For now, the best way to get started is to take a look at the examples . This document will be extended in the future.","title":"Getting started"},{"location":"language/","text":"The language This chapter characterizes the Pris domain specific language in various ways. It may help to determine where Pris is positioned relative to other languages. If you want to get your hands dirty, the examples may be a better way to get started. Paradigm Pris is purely functional , in the following sense: Pris has first-class functions: functions can be passed around as values. Functions in Pris are pure: they have no side effects. Values in Pris are immutable, there are no mutable objects. Pris is imperative , in the sense that blocks consist of statements that are executed sequentially. A statement is either assignment to a variable, a put statement that places a frame, or a return from a block. Although assignments mutate the bindings in the current scope, and put statements mutate the current frame, these mutations are only visible to the current block, and do not affect the surrounding scope. x = 1 y = { x = 2 return x } // At this point, x = 1 and y = 2. Pris is dynamically scoped , in the sense that the variables that are in scope when a function is evaluated, depend on the call site, not on the site where the function was defined. When used carelessly, this can make make programs intractable quickly. But when used with care, dynamic scoping is a powerful tool for a graphics language, reminiscent of the cascading properties of CSS . For example, we can write a title function that makes no particular choice of color, so the surrounding scope can control the color. title = function(text) { font_size = 0.2h text_align = \"center\" put t(title) at (0.5w, 0.5h) } { // This title will be red. color = #ff0000 put title(\"Slide 1\") } { // This title will be blue. color = #0000ff put title(\"Slide 2\") } Due to dynamic scoping, there are two ways to provide a value to a function: By setting a particular variable in the calling scope. By passing the value as a function argument. Variables are useful for values that do not change often, to avoid having to pass them all the time. For example, the t function uses the font_family and font_style from the surrounding scope, but accepts the text as argument. Type system Pris is strongly typed , in the sense that it reports a type error for nonsensical operations, rather than implicitly coercing values. Number types have units: a length is different from a dimensionless number. Pris is dynamically typed , in the sense that type errors in unreachable code do not cause compilation to fail. // Calling this function will trigger a type error, // but defining it does not. trigger_error = function() { return \"wrong\" + 0 } Dynamic typing is not a deep design choice, it is simply easier to implement. Pris may acquire static type checking in the future. Semantics Evaluation in Pris is strict . Function arguments are reduced to values before evaluating the function body, and the right-hand side of an assignment is evaluated fully before continuing to the next statement. Suffixes are resolved eagerly . Relative lengths are converted into absolute lengths as soon as they are evaluated, and the conversion depends on the meaning of the suffix at that time. Arithmetic with lenghts does not operate on symbolic suffixes. font_size = 0.1h x = 1em // At this point, x = 0.1h. font_size = 0.2h // At this point, x = 0.1h still. Syntax Pris is whitespace-insensitive . Whitespace separates tokens, but the amount, and the distinction between spaces and newlines, are irrelevant. Tabs and carriage returns are rejected by the parser. Pris does not have a statement separator . Rather, the grammar is constructed in such a way that statement boundaries are unambiguous. // You can put multiple statements on a line. // That doesn't mean it's a good idea though. x = 10 y = 12 put t(\"12\") z = 1 + 2 w = z","title":"The language"},{"location":"language/#the-language","text":"This chapter characterizes the Pris domain specific language in various ways. It may help to determine where Pris is positioned relative to other languages. If you want to get your hands dirty, the examples may be a better way to get started.","title":"The language"},{"location":"language/#paradigm","text":"Pris is purely functional , in the following sense: Pris has first-class functions: functions can be passed around as values. Functions in Pris are pure: they have no side effects. Values in Pris are immutable, there are no mutable objects. Pris is imperative , in the sense that blocks consist of statements that are executed sequentially. A statement is either assignment to a variable, a put statement that places a frame, or a return from a block. Although assignments mutate the bindings in the current scope, and put statements mutate the current frame, these mutations are only visible to the current block, and do not affect the surrounding scope. x = 1 y = { x = 2 return x } // At this point, x = 1 and y = 2. Pris is dynamically scoped , in the sense that the variables that are in scope when a function is evaluated, depend on the call site, not on the site where the function was defined. When used carelessly, this can make make programs intractable quickly. But when used with care, dynamic scoping is a powerful tool for a graphics language, reminiscent of the cascading properties of CSS . For example, we can write a title function that makes no particular choice of color, so the surrounding scope can control the color. title = function(text) { font_size = 0.2h text_align = \"center\" put t(title) at (0.5w, 0.5h) } { // This title will be red. color = #ff0000 put title(\"Slide 1\") } { // This title will be blue. color = #0000ff put title(\"Slide 2\") } Due to dynamic scoping, there are two ways to provide a value to a function: By setting a particular variable in the calling scope. By passing the value as a function argument. Variables are useful for values that do not change often, to avoid having to pass them all the time. For example, the t function uses the font_family and font_style from the surrounding scope, but accepts the text as argument.","title":"Paradigm"},{"location":"language/#type-system","text":"Pris is strongly typed , in the sense that it reports a type error for nonsensical operations, rather than implicitly coercing values. Number types have units: a length is different from a dimensionless number. Pris is dynamically typed , in the sense that type errors in unreachable code do not cause compilation to fail. // Calling this function will trigger a type error, // but defining it does not. trigger_error = function() { return \"wrong\" + 0 } Dynamic typing is not a deep design choice, it is simply easier to implement. Pris may acquire static type checking in the future.","title":"Type system"},{"location":"language/#semantics","text":"Evaluation in Pris is strict . Function arguments are reduced to values before evaluating the function body, and the right-hand side of an assignment is evaluated fully before continuing to the next statement. Suffixes are resolved eagerly . Relative lengths are converted into absolute lengths as soon as they are evaluated, and the conversion depends on the meaning of the suffix at that time. Arithmetic with lenghts does not operate on symbolic suffixes. font_size = 0.1h x = 1em // At this point, x = 0.1h. font_size = 0.2h // At this point, x = 0.1h still.","title":"Semantics"},{"location":"language/#syntax","text":"Pris is whitespace-insensitive . Whitespace separates tokens, but the amount, and the distinction between spaces and newlines, are irrelevant. Tabs and carriage returns are rejected by the parser. Pris does not have a statement separator . Rather, the grammar is constructed in such a way that statement boundaries are unambiguous. // You can put multiple statements on a line. // That doesn't mean it's a good idea though. x = 10 y = 12 put t(\"12\") z = 1 + 2 w = z","title":"Syntax"},{"location":"name/","text":"Name Pris is named after Pris Stratton, the Blade Runner character in turn based on the character from Dick\u2019s 1968 novel Do Androids Dream of Electric Sheep? . The fact that \u2018Pris\u2019 sounds like a prefix of \u2018presentation\u2019 might or might not have something to do with it. The fact that pris is a nice and short name for a command-line application is entirely coincidental.","title":"Name"},{"location":"name/#name","text":"Pris is named after Pris Stratton, the Blade Runner character in turn based on the character from Dick\u2019s 1968 novel Do Androids Dream of Electric Sheep? . The fact that \u2018Pris\u2019 sounds like a prefix of \u2018presentation\u2019 might or might not have something to do with it. The fact that pris is a nice and short name for a command-line application is entirely coincidental.","title":"Name"},{"location":"parser/","text":"Parser The current parser used in Pris is a hand-written parser. See src/parser.rs for more information. Previously, a parser generated by lalrpop was used. This parser was replaced mainly because of the long compile times caused by lalrpop and its many dependencies. The opportunity for better error messages and reduced binary size are other advantages. Build time Build times on Rust 1.19.0-beta.1, median and standard deviation of 3 clean builds, excluding crate download time: Version Mode Build time (s) b504558 debug 83.2 \u00b1 2.2 4bb1e60 debug 16.2 \u00b1 0.5 b504558 release 225.9 \u00b1 3.9 4bb1e60 release 36.8 \u00b1 1.9 b504558 is the lalrpop -based revision, 4bb1e60 uses the new parser. Binary size The binary size for a release build, after stripping: Version Binary size (KiB) b504558 1644.0 4bb1e60 1380.0 That is almost a 20% reduction in binary size.","title":"Parser"},{"location":"parser/#parser","text":"The current parser used in Pris is a hand-written parser. See src/parser.rs for more information. Previously, a parser generated by lalrpop was used. This parser was replaced mainly because of the long compile times caused by lalrpop and its many dependencies. The opportunity for better error messages and reduced binary size are other advantages.","title":"Parser"},{"location":"parser/#build-time","text":"Build times on Rust 1.19.0-beta.1, median and standard deviation of 3 clean builds, excluding crate download time: Version Mode Build time (s) b504558 debug 83.2 \u00b1 2.2 4bb1e60 debug 16.2 \u00b1 0.5 b504558 release 225.9 \u00b1 3.9 4bb1e60 release 36.8 \u00b1 1.9 b504558 is the lalrpop -based revision, 4bb1e60 uses the new parser.","title":"Build time"},{"location":"parser/#binary-size","text":"The binary size for a release build, after stripping: Version Binary size (KiB) b504558 1644.0 4bb1e60 1380.0 That is almost a 20% reduction in binary size.","title":"Binary size"},{"location":"subframes/","text":"Subframes Note : This is still an idea, it has not been implemented. Problem Currently, slides in Pris are not first class. There is no way to assign slides to variables, or to return slides from functions. I would like to be able to write: title_slide = function(title) { ... } title_slide(\"Section 1\") { // First slide of section 1. } title_slide(\"Section 2\") { // First slide of section 2. } Instead of having to write { put title_slide(\"Section 1\") } In particular, because you manually have to set the background color each time in the latter case (although you could also put fill_rectangle((1w, 1h)) to achieve a background color \u2014 and perhaps that is better anyway). Apart from this, Pris does not yet have animation. For this I had the idea of introducing a pause statement, like so: { put fill_circle(1em) at (0.5w, 0.5h) pause put fill_circle(1em) at (0.25w, 0.5h) put fill_circle(1em) at (0.75w, 0.5h) } The first circle would appear on the first subframe and each subframe following it, the next two circles would appear on the second subframe only. The time dimension Just like frames have a bounding box that demarcates them in space, they could have a duration that does so in time. The above box frame would have a duration of 2 frames. A put would place an animated frame (consisting of multiple subframes) at the current time, and pause would advance the current time by one. Analogous to how at tranlates a frame in space, delay would translate a frame in time. (Let's, use a f suffix for units of time, meaning \u201cframe\u201d.) This would make the dots appear one by one: { put fill_circle(1em) at (0.25w, 0.5h) delay 0f put fill_circle(1em) at (0.50w, 0.5h) delay 1f put fill_circle(1em) at (0.75w, 0.5h) delay 2f } Just like how bounding boxes grow to contain everything placed, the duration would grow to encapsulate all the entire time range (3 subframes here). In fact, with delay we do not need pause any more, but it might still be nice to have, to act as an implicit counter. Pris does not yet have clipping masks for spatial limiting, but I do want to add them in the future. Analogously, we can clip a frame in time: { put fill_circle(1em) at (0.33w, 0.5h) until 1f put fill_circle(1em) at (0.66w, 0.5h) delay 1f } This would make the circle jump, appearing on the left in the first frame, and on the right in the second frame. Open question : until suggests that the time argument is relative to the start of the current frame, but that would make it dependent on external state. It would be more natural to just limit the duration, but then \u201cuntil\u201d may not be the best name. Perhaps up_to , that aligns nicely with delay too. With this, we can theoretically build an entire presentation in one slide that has subframes. In fact, the previous example is the single-slide equivalent of { put fill_circle(1em) at (0.33w, 0.5h) } { put fill_circle(1em) at (0.66w, 0.5h) delay 1f } A unified approach I think this is the key: if slides are frames, then we can now have first-class slides, because frames are already first class. This solves the initial problem: put title_slide(\"Section 1\") until 1f delay 0f put { // First slide of section 1. } until 1f delay 1f put title_slide(\"Section 2\") until 1f delay 2f put { // First slide of section 2. } until 1f delay 3f The only downside now, is that it is not quite ergonomic. Especially having to manually specify frame times is annoying and unmaintainable, because you cannot easily insert or swap frames. We can alleviate this with a counter though: t = 0f put title_slide(\"Section 1\") until 1f delay t t = t + 1f put { // First slide of section 1. } until 1f delay t t = t + 1f put title_slide(\"Section 2\") until 1f delay t t = t + 1f put { // First slide of section 2. } until 1f delay t At this point, I feel that syntactic sugar would be helpful. Pris is a DSL after all. We can introduce an implicit t variable, make put implicitly delay everything by that, and add a clear statement that caps everything placed so far in time, and advances t . pause would do the same, but without the until , therefore not clearing the current elements. put title_slide(\"Section 1\") clear put { // Uncover a bulleted list. put some_bullet_1() pause put some_bullet_2() } clear put title_slide(\"Section 2\") clear put { // First slide of section 2. } This does look like a workable solution to me. What bothers me though, is that now there is an implicit \u201ctime origin\u201d that put respects. For consistency, should there be something similar for space? E.g. put t(\"First line\") move (0em, line_height) put t(\"Second line\") Actually, now that I write this down, I realize that I have badly wanted this for a long time. Yes , there should also be an implicit origin, with statements to mutate it. Also, it would be very natural to integrate this with the anchor. Currently, the place of the anchor is a bit ad-hoc, and the user does not have direct control over it, although you can put {} at somewhere as the last statement as a workaround. If the anchor would simply be the final value of the implicit origin, then that would unify space and time. Also, an implicit origin/anchor in time is useful too! For placement in time, the default should be to extend indefinitely into the future. I.e. once placed, elements never disappear, unless you explicitly clip them in time. But that raises a problem: what is the duration of an animation? Taking the convex hull of the timespans would make it infinite, but there is a finite time at which an animation ends, after which it is constant. We could define \u201cduration\u201d arbitrarily as that point, but it may not be what you want. For example, it would make it difficult to construct a frame with a duration of two subframes. (You could put {} delay 1f as a workaround, just like with the bounding box.) Having an anchor in time provides an elegant solution here: the last time offset becomes the duration. And with pause as a statement to advance it, it also usually has the right value. When placing an animation itself though, you may want to advance the current time by its duration. For example: a1 = animation_1() a2 = animation_2() { // Play animations in parrallel. put a1 put a2 pause max(a1.duration, a2.duration) } { // Play animations sequentially. put a1 pause a1.duration put a2 pause a2.duration } The latter example has an equivalent in space that I find myself needing often: { put t(\"Line 1\") at (1em, 1em + 1 * line_height) put t(\"Line 2\") at (1em, 1em + 2 * line_height) put t(\"Line 3\") at (1em, 1em + 3 * line_height) } With move , we could write it as follows: { t1 = t(\"Line 1\\n\") t2 = t(\"Line 2\\n\") t3 = t(\"Line 3\\n\") move (1em, 1em) put t1 move t1.anchor put t2 move t2.anchor put t3 move t3.anchor } This raises the question: should there be two variants of put ? One that places an element without moving the anchor or advancing the time, and one that does? For example, we may add a @put (syntax just an idea, better names or sigils are welcome) and have: { // Play sequentially. @put a1 @put a2 } { // Place lines below one another. move (1em, 1em) @put t\"(Line 1\\n\") @put t\"(Line 2\\n\") @put t\"(Line 3\\n\") } That again raises the question then, should delay and at be the same function, with coords having a time component in addition to space? And should move and pause be the same statement, perhaps called advance instead? Unifying coordinates in space and time does seem like a very natural thing to do that will further eliminate special cases. The syntax for coordinates could remain the same, with (x, y) constructing a coordinate where the time component is zero, and 1f (or maybe @1f or something like that to set a time coordinate apart from a number with time dimensions) would be a coordinate where the spatial component is zero. Conclusion Frames extend in space (the bounding box) and in time. Similar to how at translates a frame in space, delay translates in time. put will no longer place things at the origin, it will place them at the current anchor , which starts out at the origin. move can move the anchor by a relative offset. Similarly, put will not place things at time 0, it will place them at the current subframe , which starts out at 0. pause can advance the subframe by a relative offset. (It could be fixed to 1, but maybe it is good for consistency with move to make it variable.) clear would clip all currently placed elements in time up to the current subframe, and then advance the current subframe.","title":"Subframes"},{"location":"subframes/#subframes","text":"Note : This is still an idea, it has not been implemented.","title":"Subframes"},{"location":"subframes/#problem","text":"Currently, slides in Pris are not first class. There is no way to assign slides to variables, or to return slides from functions. I would like to be able to write: title_slide = function(title) { ... } title_slide(\"Section 1\") { // First slide of section 1. } title_slide(\"Section 2\") { // First slide of section 2. } Instead of having to write { put title_slide(\"Section 1\") } In particular, because you manually have to set the background color each time in the latter case (although you could also put fill_rectangle((1w, 1h)) to achieve a background color \u2014 and perhaps that is better anyway). Apart from this, Pris does not yet have animation. For this I had the idea of introducing a pause statement, like so: { put fill_circle(1em) at (0.5w, 0.5h) pause put fill_circle(1em) at (0.25w, 0.5h) put fill_circle(1em) at (0.75w, 0.5h) } The first circle would appear on the first subframe and each subframe following it, the next two circles would appear on the second subframe only.","title":"Problem"},{"location":"subframes/#the-time-dimension","text":"Just like frames have a bounding box that demarcates them in space, they could have a duration that does so in time. The above box frame would have a duration of 2 frames. A put would place an animated frame (consisting of multiple subframes) at the current time, and pause would advance the current time by one. Analogous to how at tranlates a frame in space, delay would translate a frame in time. (Let's, use a f suffix for units of time, meaning \u201cframe\u201d.) This would make the dots appear one by one: { put fill_circle(1em) at (0.25w, 0.5h) delay 0f put fill_circle(1em) at (0.50w, 0.5h) delay 1f put fill_circle(1em) at (0.75w, 0.5h) delay 2f } Just like how bounding boxes grow to contain everything placed, the duration would grow to encapsulate all the entire time range (3 subframes here). In fact, with delay we do not need pause any more, but it might still be nice to have, to act as an implicit counter. Pris does not yet have clipping masks for spatial limiting, but I do want to add them in the future. Analogously, we can clip a frame in time: { put fill_circle(1em) at (0.33w, 0.5h) until 1f put fill_circle(1em) at (0.66w, 0.5h) delay 1f } This would make the circle jump, appearing on the left in the first frame, and on the right in the second frame. Open question : until suggests that the time argument is relative to the start of the current frame, but that would make it dependent on external state. It would be more natural to just limit the duration, but then \u201cuntil\u201d may not be the best name. Perhaps up_to , that aligns nicely with delay too. With this, we can theoretically build an entire presentation in one slide that has subframes. In fact, the previous example is the single-slide equivalent of { put fill_circle(1em) at (0.33w, 0.5h) } { put fill_circle(1em) at (0.66w, 0.5h) delay 1f }","title":"The time dimension"},{"location":"subframes/#a-unified-approach","text":"I think this is the key: if slides are frames, then we can now have first-class slides, because frames are already first class. This solves the initial problem: put title_slide(\"Section 1\") until 1f delay 0f put { // First slide of section 1. } until 1f delay 1f put title_slide(\"Section 2\") until 1f delay 2f put { // First slide of section 2. } until 1f delay 3f The only downside now, is that it is not quite ergonomic. Especially having to manually specify frame times is annoying and unmaintainable, because you cannot easily insert or swap frames. We can alleviate this with a counter though: t = 0f put title_slide(\"Section 1\") until 1f delay t t = t + 1f put { // First slide of section 1. } until 1f delay t t = t + 1f put title_slide(\"Section 2\") until 1f delay t t = t + 1f put { // First slide of section 2. } until 1f delay t At this point, I feel that syntactic sugar would be helpful. Pris is a DSL after all. We can introduce an implicit t variable, make put implicitly delay everything by that, and add a clear statement that caps everything placed so far in time, and advances t . pause would do the same, but without the until , therefore not clearing the current elements. put title_slide(\"Section 1\") clear put { // Uncover a bulleted list. put some_bullet_1() pause put some_bullet_2() } clear put title_slide(\"Section 2\") clear put { // First slide of section 2. } This does look like a workable solution to me. What bothers me though, is that now there is an implicit \u201ctime origin\u201d that put respects. For consistency, should there be something similar for space? E.g. put t(\"First line\") move (0em, line_height) put t(\"Second line\") Actually, now that I write this down, I realize that I have badly wanted this for a long time. Yes , there should also be an implicit origin, with statements to mutate it. Also, it would be very natural to integrate this with the anchor. Currently, the place of the anchor is a bit ad-hoc, and the user does not have direct control over it, although you can put {} at somewhere as the last statement as a workaround. If the anchor would simply be the final value of the implicit origin, then that would unify space and time. Also, an implicit origin/anchor in time is useful too! For placement in time, the default should be to extend indefinitely into the future. I.e. once placed, elements never disappear, unless you explicitly clip them in time. But that raises a problem: what is the duration of an animation? Taking the convex hull of the timespans would make it infinite, but there is a finite time at which an animation ends, after which it is constant. We could define \u201cduration\u201d arbitrarily as that point, but it may not be what you want. For example, it would make it difficult to construct a frame with a duration of two subframes. (You could put {} delay 1f as a workaround, just like with the bounding box.) Having an anchor in time provides an elegant solution here: the last time offset becomes the duration. And with pause as a statement to advance it, it also usually has the right value. When placing an animation itself though, you may want to advance the current time by its duration. For example: a1 = animation_1() a2 = animation_2() { // Play animations in parrallel. put a1 put a2 pause max(a1.duration, a2.duration) } { // Play animations sequentially. put a1 pause a1.duration put a2 pause a2.duration } The latter example has an equivalent in space that I find myself needing often: { put t(\"Line 1\") at (1em, 1em + 1 * line_height) put t(\"Line 2\") at (1em, 1em + 2 * line_height) put t(\"Line 3\") at (1em, 1em + 3 * line_height) } With move , we could write it as follows: { t1 = t(\"Line 1\\n\") t2 = t(\"Line 2\\n\") t3 = t(\"Line 3\\n\") move (1em, 1em) put t1 move t1.anchor put t2 move t2.anchor put t3 move t3.anchor } This raises the question: should there be two variants of put ? One that places an element without moving the anchor or advancing the time, and one that does? For example, we may add a @put (syntax just an idea, better names or sigils are welcome) and have: { // Play sequentially. @put a1 @put a2 } { // Place lines below one another. move (1em, 1em) @put t\"(Line 1\\n\") @put t\"(Line 2\\n\") @put t\"(Line 3\\n\") } That again raises the question then, should delay and at be the same function, with coords having a time component in addition to space? And should move and pause be the same statement, perhaps called advance instead? Unifying coordinates in space and time does seem like a very natural thing to do that will further eliminate special cases. The syntax for coordinates could remain the same, with (x, y) constructing a coordinate where the time component is zero, and 1f (or maybe @1f or something like that to set a time coordinate apart from a number with time dimensions) would be a coordinate where the spatial component is zero.","title":"A unified approach"},{"location":"subframes/#conclusion","text":"Frames extend in space (the bounding box) and in time. Similar to how at translates a frame in space, delay translates in time. put will no longer place things at the origin, it will place them at the current anchor , which starts out at the origin. move can move the anchor by a relative offset. Similarly, put will not place things at time 0, it will place them at the current subframe , which starts out at 0. pause can advance the subframe by a relative offset. (It could be fixed to 1, but maybe it is good for consistency with move to make it variable.) clear would clip all currently placed elements in time up to the current subframe, and then advance the current subframe.","title":"Conclusion"},{"location":"reference/at/","text":"at at(frame: frame, offset: coord) - frame Move a frame by the given offset. This is used to position elements on the canvas, or relative to a scope, and the function is usually called with infix notation. Example: // Place an image in the top-left corner of the canvas. put image(\"logo.png\") at (1em, 1em)","title":"at"},{"location":"reference/at/#at","text":"at(frame: frame, offset: coord) - frame Move a frame by the given offset. This is used to position elements on the canvas, or relative to a scope, and the function is usually called with infix notation. Example: // Place an image in the top-left corner of the canvas. put image(\"logo.png\") at (1em, 1em)","title":"at"},{"location":"reference/canvas_size/","text":"canvas_size canvas_size: vec2 A variable that sets the aspect ratio of the canvas. Must be assigned in the global scope. The last assignment to this variable determines the canvas size for all slides in the document, it is currently not possible to have slides of different sizes in a single document. Note that after changing the canvas size, variables that had been assigned a value relative to the canvas size, continue to hold their absolute value, which may no longer make sense for the new canvas size. For example: canvas_size = (1, 1) half = 0.5w canvas_size = (2, 2) // \"half\" is now effectively 0.25w, no longer half the canvas width.","title":"canvas_size"},{"location":"reference/canvas_size/#canvas_size","text":"canvas_size: vec2 A variable that sets the aspect ratio of the canvas. Must be assigned in the global scope. The last assignment to this variable determines the canvas size for all slides in the document, it is currently not possible to have slides of different sizes in a single document. Note that after changing the canvas size, variables that had been assigned a value relative to the canvas size, continue to hold their absolute value, which may no longer make sense for the new canvas size. For example: canvas_size = (1, 1) half = 0.5w canvas_size = (2, 2) // \"half\" is now effectively 0.25w, no longer half the canvas width.","title":"canvas_size"},{"location":"reference/fill_circle/","text":"fill_circle fill_circle(radius: len) - frame Draw a solid circle. The origin of the returned circle is in its center. The fill color is taken from the color variable.","title":"fill_circle"},{"location":"reference/fill_circle/#fill_circle","text":"fill_circle(radius: len) - frame Draw a solid circle. The origin of the returned circle is in its center. The fill color is taken from the color variable.","title":"fill_circle"},{"location":"reference/fill_polygon/","text":"fill_polygon fill_polygon(vertices: list of coord) - frame Draw a solid polygon. The fill color is taken from the color variable. For example, drawing a rectangle with 2em sides: vertices = [(-1em, 1em); (1em, 1em); (1em, -1em); (-1em, -1em)] put fill_polygon(vertices)","title":"fill_polygon"},{"location":"reference/fill_polygon/#fill_polygon","text":"fill_polygon(vertices: list of coord) - frame Draw a solid polygon. The fill color is taken from the color variable. For example, drawing a rectangle with 2em sides: vertices = [(-1em, 1em); (1em, 1em); (1em, -1em); (-1em, -1em)] put fill_polygon(vertices)","title":"fill_polygon"},{"location":"reference/fill_rectangle/","text":"fill_rectangle fill_rectangle(size: coord) - frame Draw a solid rectangle. The origin of the returned rectangle is at its top-left corner. The fill color is taken from the color variable.","title":"fill_rectangle"},{"location":"reference/fill_rectangle/#fill_rectangle","text":"fill_rectangle(size: coord) - frame Draw a solid rectangle. The origin of the returned rectangle is at its top-left corner. The fill color is taken from the color variable.","title":"fill_rectangle"},{"location":"reference/fit/","text":"fit fit(frame: frame, size: coord) - frame Scale a frame to fit inside a rectangle of the given size, respecting aspect ratio.","title":"fit"},{"location":"reference/fit/#fit","text":"fit(frame: frame, size: coord) - frame Scale a frame to fit inside a rectangle of the given size, respecting aspect ratio.","title":"fit"},{"location":"reference/glyph/","text":"glyph glyph(glyph_index: num) - frame Render a single glyph, selected by glyph index, which must be a positive integer. Font and color are controlled in the same way as with t .","title":"glyph"},{"location":"reference/glyph/#glyph","text":"glyph(glyph_index: num) - frame Render a single glyph, selected by glyph index, which must be a positive integer. Font and color are controlled in the same way as with t .","title":"glyph"},{"location":"reference/hyperlink/","text":"hyperlink hyperlink(uri: str, size: coord) - frame Create a rectangular area of size size that opens the given URI when clicked. The frame itself has no visual artifacts, it can be added over text or over a rectangle, for example. The origin of the clickable area is in the top-left corner.","title":"hyperlink"},{"location":"reference/hyperlink/#hyperlink","text":"hyperlink(uri: str, size: coord) - frame Create a rectangular area of size size that opens the given URI when clicked. The frame itself has no visual artifacts, it can be added over text or over a rectangle, for example. The origin of the clickable area is in the top-left corner.","title":"hyperlink"},{"location":"reference/image/","text":"image image(fname: str) - frame Load a PNG or SVG graphic from the file with path fname . Currently the path is relative to the working directory, but it should be made relative to the source file. The origin of the returned frame is in the top-left corner. The size of the image relative to the canvas depends on the input image, and is often not meaningful. To resize the image, use the fit function.","title":"image"},{"location":"reference/image/#image","text":"image(fname: str) - frame Load a PNG or SVG graphic from the file with path fname . Currently the path is relative to the working directory, but it should be made relative to the source file. The origin of the returned frame is in the top-left corner. The size of the image relative to the canvas depends on the input image, and is often not meaningful. To resize the image, use the fit function.","title":"image"},{"location":"reference/line/","text":"line line(pos: coord) - frame Draw a line from the origin to the given position. The origin of the returned line is at the first vertex. The line color is taken from the color variable, the width from the line_width variable.","title":"line"},{"location":"reference/line/#line","text":"line(pos: coord) - frame Draw a line from the origin to the given position. The origin of the returned line is at the first vertex. The line color is taken from the color variable, the width from the line_width variable.","title":"line"},{"location":"reference/sqrt/","text":"sqrt sqrt(x: num) - num sqrt(x: len\u00b2) - len sqrt(x: len\u2074) - len\u00b2 ... sqrt(x: len\u00b2\u207f) - len\u207f Return the square root of a number or length.","title":"sqrt"},{"location":"reference/sqrt/#sqrt","text":"sqrt(x: num) - num sqrt(x: len\u00b2) - len sqrt(x: len\u2074) - len\u00b2 ... sqrt(x: len\u00b2\u207f) - len\u207f Return the square root of a number or length.","title":"sqrt"},{"location":"reference/str/","text":"str str(x: num) - str Turn a number into a string.","title":"str"},{"location":"reference/str/#str","text":"str(x: num) - str Turn a number into a string.","title":"str"},{"location":"reference/t/","text":"t t(text: str) - frame Render a piece of text. This function will likely be renamed to text in the future, when string prefixes are supported. The font can be selected with the font_family and font_style variables. Alignment can be controlled with the text_align variable, which must be one of \"left\" , \"center\" , or \"right\" . Line height is controlled by the line_height variable. The origin of the returned frame is on the baseline of the first line. The text color is taken from the color variable.","title":"t"},{"location":"reference/t/#t","text":"t(text: str) - frame Render a piece of text. This function will likely be renamed to text in the future, when string prefixes are supported. The font can be selected with the font_family and font_style variables. Alignment can be controlled with the text_align variable, which must be one of \"left\" , \"center\" , or \"right\" . Line height is controlled by the line_height variable. The origin of the returned frame is on the baseline of the first line. The text color is taken from the color variable.","title":"t"},{"location":"README.theme/","text":"Kilsbergen A clean MkDocs theme. This theme is designed for Tako , Pris , and Noblit . It is not flexible on purpose: it supports everything I need, and nothing more. Demos Tako documentation Pris documentation Features Responsive design Zero javascript License Kilsbergen is licensed under the Apache 2.0 license. In the generated documentation, it is fine to just link to this readme from a comment.","title":"Kilsbergen"},{"location":"README.theme/#kilsbergen","text":"A clean MkDocs theme. This theme is designed for Tako , Pris , and Noblit . It is not flexible on purpose: it supports everything I need, and nothing more.","title":"Kilsbergen"},{"location":"README.theme/#demos","text":"Tako documentation Pris documentation","title":"Demos"},{"location":"README.theme/#features","text":"Responsive design Zero javascript","title":"Features"},{"location":"README.theme/#license","text":"Kilsbergen is licensed under the Apache 2.0 license. In the generated documentation, it is fine to just link to this readme from a comment.","title":"License"}]}