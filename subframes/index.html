
<!DOCTYPE html>
<html>
<head>
  <!--
    Kilsbergen MkDocs theme copyright 2019 Ruud van Asseldonk.
    Licensed under the Apache 2.0 license.
    See https://github.com/ruuda/kilsbergen.
  -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Subframes — Pris</title>
  <!-- Out of the options of rsms.me + Google Fonts, self-hosting, and only
    Google Fonts, the latter is by far the fastest when the docs themselves are
    not on a CDN, even though it's two additional domains to connect to. -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&display=swap" rel="stylesheet">
  <link href="https://docs.ruuda.nl/pris/subframes/" rel="canonical">
  <style>
  /* Inter font family, copyright Rasmus Andersson, licensed under SIL OFL 1.1,
     see https://rsms.me/inter and https://rsms.me/inter/inter.css. */
  @font-face {
    font-family: 'Inter';
    font-style: normal;
    font-weight: 100 900;
    font-display: swap;
    src: url('https://rsms.me/inter/font-files/Inter-roman.var.woff2?v=3.19') format('woff2');
    font-named-instance: 'Regular';
  }
  @font-face {
    font-family: 'Inter';
    font-style: italic;
    font-weight: 100 900;
    font-display: swap;
    src: url('https://rsms.me/inter/font-files/Inter-italic.var.woff2?v=3.19') format('woff2');
    font-named-instance: 'Italic';
  }
  /* Modular scale with exponent 1.7^(1/3). The 1.7 was chosen as the line hight
     that goes well with Inter. Previously I used 1.59, but it was just too tight.
     0.59em
     0.70em
     1.00em
     1.19em
     1.42em
     1.70em
     2.02em
     2.42em
  */
  * { margin: 0; padding: 0; border-spacing: 0; }
  html {
    font-family: Inter, Roboto, sans-serif;
    /*
    Turn on character variant 8 for Inter, which puts serifs on the uppercase I.
    Also turn on variant 1, which has a curved 1.
    Disable contextual alternates for now. There is a bug, either in Inter or
    in Chrome (https://crbug.com/1046095) that causes colons after a <strong> to
    be raised above the baseline.
    */
    font-feature-settings: 'cv01' 1, 'cv08' 1, 'calt' 0;

    font-size: 16px;
    line-height: 1.7em;
    background-color: #fff;
    height: 100%;
  }
  em {
    /* The variable font from Google Fonts uses a slant axis, it does not come
       with a separate true italic. (But Inter doesn't have a true italic either
       way.) */
    font-style: oblique 10deg;
  }
  body {
    height: 100%;
  }
  #content {
    display: grid;
    grid-template-columns: auto 16rem 50rem auto;
    color: #333;
    min-height: 100%;
  }
  #main {
    grid-area: 1 / 3 / 2 / 4;
    padding: 2.2rem;
    padding-left: 4rem;
    padding-right: 4rem;
    overflow: hidden;
  }
  #breadcrumbs {
    margin-bottom: 3rem;
    word-spacing: 0.3em;
    color: #78a;
  }
  #breadcrumbs a {
    word-spacing: 0;
    color: #78a;
  }
  article {
    margin-top: 1.3rem;
  }
  h1, h2, h3 {
    font-weight: 600;
    font-size: 1rem;
    color: #444;
    position: relative;
  }
  h1 {
    font-size: 2rem;
    margin-bottom: 2.1rem;
    line-height: 2.42rem;
    margin-top: -0.35rem;
    margin-bottom: 1.75rem;
  }
  h2 {
    font-size: 1.42rem;
    margin-top: 3.5rem;
    margin-bottom: 1.6rem;
  }
  .headerlink {
    position: absolute;
    left: -0.9em;
    width: 1em;
    opacity: 0.0;
    transition: opacity 0.2s ease-in;
  }
  /* Don't show the link for h1, usually you only have a single h1 at the top
     of the page, so it doesn't make much sense to add an anchor there, and with
     the larger font size, it doesn't fit in a narrow viewport. */
  h2:hover .headerlink, h3:hover .headerlink {
    opacity: 1.0;
  }
  code {
    font-family: 'Roboto Mono', monospace;
    font-size: 0.84rem;
    line-height: 1.5rem;
  }
  h3 > code {
    /* Roboto Mono 500 is about as heavy as Inter semibold (600). */
    font-weight: 500;
  }
  abbr {
    text-transform: uppercase;
    /* Downsize so caps are x-height, and compensate weight loss. */
    font-size: 0.78rem;
    font-weight: 500;
    letter-spacing: 0.05rem;
    /* Prevent abbrs from changing the line height of lines in which they occur. */
    line-height: 0;
  }
  sub, sup {
    /* Don't disturb the line height of normal text. */
    line-height: 0rem;
    font-size: 0.78rem;
    font-weight: 500;
  }
  p > code,
  a > code,
  h3 > code,
  li > code,
  td > code,
  dt > code,
  dd > code {
    background-color: #f0f0f0;
    padding: 0.13rem;
    padding-left: 0.3rem;
    padding-right: 0.3rem;
    border-radius: 0.2rem;
    line-height: 1rem;
  }
  h3 {
    padding-top: 0.9rem;
    padding-bottom: 0.8rem;
  }
  h3 > code {
    margin-left: -0.1rem;
  }
  a {
    color: #36d;
    text-decoration: none;
  }
  p, ul, ol, dl, pre, table {
    /* Same space as line height, leave exactly one line blank. */
    margin-bottom: 1.7rem;
  }
  pre {
    padding-top: 0.8rem;
    padding-bottom: 0.9rem;
    padding-left: 1.19rem;
    padding-right: 0;
    background-color: #f8f8f8;
    border-radius: 0 0.2rem 0.2rem 0;
    border-left: 0.3rem solid #d5d8e0;
    overflow-x: auto;
  }
  pre > code {
    margin-right: 1.41rem;
    color: #555;
  }
  code .k { color: #36d; }
  code .kt, code .nb { color: #d36; }
  code .c1, code .cm { color: #d36; font-style: italic; }
  code .s { color: #c43; }
  ul, ol {
    list-style-type: none;
    counter-reset: item;
  }
  table {
    font-variant-numeric: tabular-nums;
  }
  th, td {
    padding-right: 2rem;
  }
  th {
    text-align: left;
  }
  td > img {
    display: block;
    padding-top: 1em;
    padding-bottom: 1em;
  }
  dl {
    display: grid;
    grid-template-columns: 1fr 4fr;
    grid-column-gap: 2em;
  }
  dl dt {
    text-align: right;
  }
  #main ul li:before {
    color: #555;
    content: '\2022';
    display: inline-block;
    font-weight: 700;
    margin-left: -0.9rem;
    width: 0.9rem;
  }
  #main ul li {
    margin-left: 0.87rem;
  }
  #main ol li:before {
    content: counter(item);
    display: inline-block;
    font-weight: 700;
    width: 0.8rem;
    margin-left: -1.6rem;
    padding-right: 0.8rem;
  }
  #main ol li {
    margin-left: 1.6rem;
    counter-increment: item;
  }
  #nav-prev-next {
    margin-top: 3.4rem;
    padding-bottom: 3.3rem;
  }
  #nav-prev, #nav-next, #repo-link {
    display: inline-block;
  }
  #nav-prev {
    float: left;
  }
  #nav-next, #repo-link {
    float: right;
    text-align: right;
  }
  #nav-prev::before {
    content: '\219e';
    padding-right: 0.5em;
  }
  #nav-next::after {
    content: '\21a0';
    padding-left: 0.5em;
  }
  aside {
    grid-area: 1 / 1 / 2 / 3;
    border-right: 1px solid #eee;
    background-color: #fafafa;
    color: #78a;
  }
  aside nav {
    margin-top: 9rem;
    padding-bottom: 3.4rem;
    width: 14rem;
    float: right;
    /* Put the active chapter border over the sidebar border. */
    margin-right: -1px;
  }
  aside a {
    color: inherit;
  }
  aside .toc-section {
    font-weight: 700;
  }
  aside ul {
    margin-bottom: 0;
  }
  aside li {
    overflow: hidden;
    text-overflow: ellipsis;
  }
  aside li ul {
    padding-top: 0.6rem;
    padding-bottom: 1.1rem;
  }
  aside li.toc-section {
    margin-top: 1.7rem;
  }
  aside li.toc-section {
    color: #36d;
  }
  aside li.current, aside li ul {
    border-right: 0.3em solid #d5d8e0;
    padding-left: 1em;
    margin-left: -1em;
  }
  aside li.toc-chapter.current {
    font-weight: 600;
  }
  aside li.toc-heading {
    padding-left: 1em;
    padding-right: 0.3em;
  }

  @media(max-width: 63rem)
  {
    #content {
      /* Manual implementation of max-width: on narrower viewports,
         auto-size the body. */
      grid-template-columns: 0 16rem auto 0;
    }
  }

  @media(max-width: 1150px)
  {
    html { font-size: 15px; }
  }

  /* Move the sidebar TOC below content at small widths. */
  @media(max-width: 800px)
  {
    #content {
      display: block;
    }
    aside {
      border-top: 1px solid #eee;
      border-right: 0px none;
      padding-top: 1.7em;
    }
    aside nav {
      margin-left: 4em;
      margin-top: 1.7em;
      margin-right: 0;
      float: none;
      width: auto;
    }
    #main {
      padding-bottom: 1.7em;
    }
    /* Now that the TOC is full-width, adding the border on the right to
       highlight the active page is not as clear anymore, it can be far away.
       The current chapter is still in boldface, but that does not work for
       section indexes. So point a guillemet at it as well. */
    aside li.current, aside li ul {
      border-right: 0px none;
      position: relative;
    }
    aside li.current:before {
      content: '\203a';
      position: absolute;
      left: 0;
    }
  }

  /* Use less generous margins for very narrow viewports. */
  @media(max-width: 650px)
  {
    #main {
      padding-left: 2rem;
      padding-right: 2rem;
    }
    aside nav {
      margin-left: 2rem;
      padding-bottom: 2rem;
    }
  }

  @media(max-width: 450px)
  {
    #main {
      padding-left: 1.7em;
      padding-right: 1.7em;
    }
    aside nav {
      margin-left: 1.7em;
    }
  }
  </style>
</head>
<body>
  <div id="content">
    <div id="main">
      <nav id="breadcrumbs">
        <a href="https://docs.ruuda.nl/pris/">Pris</a>
         › <a href="../parser/">Internals</a> 
         › <a href="./">Subframes</a> 
        <a id="repo-link" href="https://github.com/ruuda/pris">GitHub</a>
      </nav>
      <article>
        <h1 id="subframes">Subframes<a class="headerlink" href="#subframes">&para;</a></h1>
<p><strong>Note</strong>: This is still an idea, it has not been implemented.</p>
<h2 id="problem">Problem<a class="headerlink" href="#problem">&para;</a></h2>
<p>Currently, slides in Pris are not first class. There is no way to assign slides
to variables, or to return slides from functions. I would like to be able to
write:</p>
<pre><code>title_slide = function(title) { ... }

title_slide("Section 1")

{
  // First slide of section 1.
}

title_slide("Section 2")

{
  // First slide of section 2.
}
</code></pre>
<p>Instead of having to write</p>
<pre><code>{
  put title_slide("Section 1")
}
</code></pre>
<p>In particular, because you manually have to set the background color each time
in the latter case (although you could also <code>put fill_rectangle((1w, 1h))</code> to
achieve a background color — and perhaps that is better anyway).</p>
<p>Apart from this, Pris does not yet have animation. For this I had the idea of
introducing a <code>pause</code> statement, like so:</p>
<pre><code>{
  put fill_circle(1em) at (0.5w, 0.5h)
  pause
  put fill_circle(1em) at (0.25w, 0.5h)
  put fill_circle(1em) at (0.75w, 0.5h)
}
</code></pre>
<p>The first circle would appear on the first subframe and each subframe following
it, the next two circles would appear on the second subframe only.</p>
<h2 id="the-time-dimension">The time dimension<a class="headerlink" href="#the-time-dimension">&para;</a></h2>
<p>Just like frames have a bounding box that demarcates them in space, they could
have a duration that does so in time. The above box frame would have a duration
of 2 frames. A <code>put</code> would place an animated frame (consisting of multiple
subframes) at the current time, and <code>pause</code> would advance the current time by
one.</p>
<p>Analogous to how <code>at</code> tranlates a frame in space, <code>delay</code> would translate a
frame in time. (Let's, use a <code>f</code> suffix for units of time, meaning “frame”.)
This would make the dots appear one by one:</p>
<pre><code>{
  put fill_circle(1em) at (0.25w, 0.5h) delay 0f
  put fill_circle(1em) at (0.50w, 0.5h) delay 1f
  put fill_circle(1em) at (0.75w, 0.5h) delay 2f
}
</code></pre>
<p>Just like how bounding boxes grow to contain everything placed, the duration
would grow to encapsulate all the entire time range (3 subframes here). In fact,
with <code>delay</code> we do not need <code>pause</code> any more, but it might still be nice to
have, to act as an implicit counter.</p>
<p>Pris does not yet have clipping masks for spatial limiting, but I do want to add
them in the future. Analogously, we can clip a frame in time:</p>
<pre><code>{
  put fill_circle(1em) at (0.33w, 0.5h) until 1f
  put fill_circle(1em) at (0.66w, 0.5h) delay 1f
}
</code></pre>
<p>This would make the circle jump, appearing on the left in the first frame, and
on the right in the second frame.</p>
<blockquote>
<p><strong>Open question</strong>: <code>until</code> suggests that the time argument is relative to the
start of the current frame, but that would make it dependent on external
state. It would be more natural to just limit the duration, but then “until”
may not be the best name. Perhaps <code>up_to</code>, that aligns nicely with <code>delay</code> too.</p>
</blockquote>
<p>With this, we can theoretically build an entire presentation in one slide that
has subframes. In fact, the previous example is the single-slide equivalent of</p>
<pre><code>{
  put fill_circle(1em) at (0.33w, 0.5h)
}

{
  put fill_circle(1em) at (0.66w, 0.5h) delay 1f
}
</code></pre>
<h2 id="a-unified-approach">A unified approach<a class="headerlink" href="#a-unified-approach">&para;</a></h2>
<p>I think this is the key: if slides <em>are</em> frames, then we can now have
first-class slides, because frames are already first class. This solves the
initial problem:</p>
<pre><code>put title_slide("Section 1") until 1f delay 0f

put
{
  // First slide of section 1.
}
until 1f delay 1f

put title_slide("Section 2") until 1f delay 2f

put
{
  // First slide of section 2.
}
until 1f delay 3f
</code></pre>
<p>The only downside now, is that it is not quite ergonomic. Especially having to
manually specify frame times is annoying and unmaintainable, because you cannot
easily insert or swap frames. We can alleviate this with a counter though:</p>
<pre><code>t = 0f

put title_slide("Section 1") until 1f delay t
t = t + 1f

put
{
  // First slide of section 1.
}
until 1f delay t
t = t + 1f

put title_slide("Section 2") until 1f delay t
t = t + 1f

put
{
  // First slide of section 2.
}
until 1f delay t
</code></pre>
<p>At this point, I feel that syntactic sugar would be helpful. Pris is a
<abbr>DSL</abbr> after all. We can introduce an implicit <code>t</code> variable,
make <code>put</code> implicitly delay everything by that, and add a <code>clear</code> statement
that caps everything placed so far in time, and advances <code>t</code>. <code>pause</code> would do
the same, but without the <code>until</code>, therefore not clearing the current elements.</p>
<pre><code>put title_slide("Section 1")

clear
put
{
  // Uncover a bulleted list.
  put some_bullet_1()
  pause
  put some_bullet_2()
}

clear
put title_slide("Section 2")

clear
put
{
  // First slide of section 2.
}
</code></pre>
<p>This does look like a workable solution to me. What bothers me though, is that
now there is an implicit “time origin” that <code>put</code> respects. For consistency,
should there be something similar for space? E.g.</p>
<pre><code>put t("First line")
move (0em, line_height)
put t("Second line")
</code></pre>
<p>Actually, now that I write this down, I realize that I have badly wanted this
for a long time. <strong>Yes</strong>, there should also be an implicit origin, with
statements to mutate it.</p>
<p>Also, it would be very natural to integrate this with the anchor. Currently, the
place of the anchor is a bit ad-hoc, and the user does not have direct control
over it, although you can <code>put {} at somewhere</code> as the last statement as a
workaround. If the anchor would simply be the final value of the implicit
origin, then that would unify space and time.</p>
<p>Also, an implicit origin/anchor in time is useful too! For placement in time,
the default should be to extend indefinitely into the future. I.e. once placed,
elements never disappear, unless you explicitly clip them in time. But that
raises a problem: what is the duration of an animation? Taking the convex hull
of the timespans would make it infinite, but there is a finite time at which an
animation ends, after which it is constant. We could define “duration”
arbitrarily as that point, but it may not be what you want. For example, it
would make it difficult to construct a frame with a duration of two subframes.
(You could <code>put {} delay 1f</code> as a workaround, just like with the bounding box.)
Having an anchor in time provides an elegant solution here: the last time offset
becomes the duration. And with <code>pause</code> as a statement to advance it, it also
usually has the right value.</p>
<p>When placing an animation itself though, you may want to advance the current
time by its duration. For example:</p>
<pre><code>a1 = animation_1()
a2 = animation_2()

{
  // Play animations in parrallel.
  put a1
  put a2
  pause max(a1.duration, a2.duration)
}

{
  // Play animations sequentially.
  put a1
  pause a1.duration
  put a2
  pause a2.duration
}
</code></pre>
<p>The latter example has an equivalent in space that I find myself needing often:</p>
<pre><code>{
  put t("Line 1") at (1em, 1em + 1 * line_height)
  put t("Line 2") at (1em, 1em + 2 * line_height)
  put t("Line 3") at (1em, 1em + 3 * line_height)
}
</code></pre>
<p>With <code>move</code>, we could write it as follows:</p>
<pre><code>{
  t1 = t("Line 1\n")
  t2 = t("Line 2\n")
  t3 = t("Line 3\n")
  move (1em, 1em)
  put t1
  move t1.anchor
  put t2
  move t2.anchor
  put t3
  move t3.anchor
}
</code></pre>
<p>This raises the question: should there be two variants of <code>put</code>? One that places
an element without moving the anchor or advancing the time, and one that does?
For example, we may add a <code>@put</code> (syntax just an idea, better names or sigils
are welcome) and have:</p>
<pre><code>{
  // Play sequentially.
  @put a1
  @put a2
}

{
  // Place lines below one another.
  move (1em, 1em)
  @put t"(Line 1\n")
  @put t"(Line 2\n")
  @put t"(Line 3\n")
}
</code></pre>
<p>That again raises the question then, should <code>delay</code> and <code>at</code> be the same
function, with coords having a time component in addition to space? And should
<code>move</code> and <code>pause</code> be the same statement, perhaps called <code>advance</code> instead?</p>
<p>Unifying coordinates in space and time does seem like a very natural thing to do
that will further eliminate special cases. The syntax for coordinates could
remain the same, with <code>(x, y)</code> constructing a coordinate where the time
component is zero, and <code>1f</code> (or maybe <code>@1f</code> or something like that to set a time
coordinate apart from a number with time dimensions) would be a coordinate where
the spatial component is zero.</p>
<h2 id="conclusion">Conclusion<a class="headerlink" href="#conclusion">&para;</a></h2>
<ul>
<li>Frames extend in space (the bounding box) and in time.</li>
<li>Similar to how <code>at</code> translates a frame in space, <code>delay</code> translates in time.</li>
<li><code>put</code> will no longer place things at the origin, it will place them at the
   current <em>anchor</em>, which starts out at the origin.</li>
<li><code>move</code> can move the anchor by a relative offset.</li>
<li>Similarly, <code>put</code> will not place things at time 0, it will place them at the
   current <em>subframe</em>, which starts out at 0.</li>
<li><code>pause</code> can advance the subframe by a relative offset. (It could be fixed to
   1, but maybe it is good for consistency with <code>move</code> to make it variable.)</li>
<li><code>clear</code> would clip all currently placed elements in time up to the current
   subframe, and then advance the current subframe.</li>
</ul>
      </article>
      <nav id="nav-prev-next">
        <a id="nav-prev" href="../parser/" title="Parser">Previous</a>
        </nav>
      </div>
    <aside>
      <nav>
        <ul>
        <li class="toc-section"><a href="..">Overview</a></li>
          <li class="toc-section
            "><a href="../getting-started/">User Guide</a></li>
          
            <li class="toc-chapter
              "><a href="../getting-started/">Getting started</a></li>
            
            <li class="toc-chapter
              "><a href="../building/">Building</a></li>
            
            <li class="toc-chapter
              "><a href="../language/">The language</a></li>
            <li class="toc-section"><a href="https://github.com/ruuda/pris/tree/master/examples">Examples</a></li>
          <li class="toc-section
            "><a href="../reference/at/">Reference</a></li>
          
            <li class="toc-chapter
              "><a href="../reference/at/">at</a></li>
            
            <li class="toc-chapter
              "><a href="../reference/canvas_size/">canvas_size</a></li>
            
            <li class="toc-chapter
              "><a href="../reference/fill_circle/">fill_circle</a></li>
            
            <li class="toc-chapter
              "><a href="../reference/fill_polygon/">fill_polygon</a></li>
            
            <li class="toc-chapter
              "><a href="../reference/fill_rectangle/">fill_rectangle</a></li>
            
            <li class="toc-chapter
              "><a href="../reference/fit/">fit</a></li>
            
            <li class="toc-chapter
              "><a href="../reference/glyph/">glyph</a></li>
            
            <li class="toc-chapter
              "><a href="../reference/hyperlink/">hyperlink</a></li>
            
            <li class="toc-chapter
              "><a href="../reference/image/">image</a></li>
            
            <li class="toc-chapter
              "><a href="../reference/line/">line</a></li>
            
            <li class="toc-chapter
              "><a href="../reference/sqrt/">sqrt</a></li>
            
            <li class="toc-chapter
              "><a href="../reference/str/">str</a></li>
            
            <li class="toc-chapter
              "><a href="../reference/t/">t</a></li>
            <li class="toc-section
            "><a href="../background/">About</a></li>
          
            <li class="toc-chapter
              "><a href="../background/">Background</a></li>
            
            <li class="toc-chapter
              "><a href="../name/">Name</a></li>
            <li class="toc-section
            "><a href="../parser/">Internals</a></li>
          
            <li class="toc-chapter
              "><a href="../parser/">Parser</a></li>
            
            <li class="toc-chapter
               current"><a href="./">Subframes</a></li>
            <li><ul>
                <li class="toc-heading"><a href="#problem">Problem</a></li>
                <li class="toc-heading"><a href="#the-time-dimension">The time dimension</a></li>
                <li class="toc-heading"><a href="#a-unified-approach">A unified approach</a></li>
                <li class="toc-heading"><a href="#conclusion">Conclusion</a></li>
                </ul></li>
               </ul>
      </nav>
    </aside>
  </div>
</body>
</html>